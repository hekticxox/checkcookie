/**
 * session_checker.js
 * 
 * Usage: node session_checker.js
 * 
 * Scans a directory of Netscape-format cookie files (.txt),
 * deduplicates by domain, splits mixed-domain cookie files,
 * and checks login session validity by opening the appropriate
 * site in Puppeteer. Supports Manual or Auto inspection modes.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");
const puppeteer = require("puppeteer");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function ask(question) {
  return new Promise((resolve) => rl.question(question, resolve));
}

const ASCII_HEADER = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                              â•‘
â•‘    ðŸš€  SESSION CHECKER - COOKIE LOGIN TEST   â•‘
â•‘                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;

const LOGIN_KEYWORDS = [
  "sign in",
  "log in",
  "login",
  "password",
  "forgot password",
  "enter your password",
  "authentication",
  "two-factor",
  "2fa",
];

// Default domain => test URLs (logged-in page)
const DOMAIN_TEST_URLS = {
  "linkedin.com": "https://www.linkedin.com/feed/",
  "accounts.google.com": "https://myaccount.google.com/",
  "google.com": "https://myaccount.google.com/",
  "gmail.com": "https://mail.google.com/mail/u/0/#inbox",
  "facebook.com": "https://www.facebook.com/me",
  "twitter.com": "https://twitter.com/home",
  "tiktok.com": "https://www.tiktok.com/upload?lang=en",
  "vancity.com": "https://banking.vancity.com/",
  // add more popular sites here...
};

// -------------------------- Utilities --------------------------

/** Recursively find all *.txt files in dir */
async function findCookieFiles(dir) {
  let results = [];
  const list = await fs.promises.readdir(dir, { withFileTypes: true });
  for (const entry of list) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results = results.concat(await findCookieFiles(fullPath));
    } else if (entry.isFile() && entry.name.endsWith(".txt")) {
      results.push(fullPath);
    }
  }
  return results;
}

/** Parse Netscape-format cookie file into domain => cookie lines map */
async function parseNetscapeCookies(filePath) {
  const text = await fs.promises.readFile(filePath, "utf8");
  const lines = text.split(/\r?\n/).filter((l) => l.trim() && !l.startsWith("#"));
  // Map domain => array of cookie lines
  const domainMap = new Map();
  for (const line of lines) {
    const parts = line.split(/\t/);
    if (parts.length < 7) continue;
    const domain = parts[0].replace(/^\./, ""); // normalize domain, remove leading dot
    if (!domainMap.has(domain)) domainMap.set(domain, []);
    domainMap.get(domain).push(line);
  }
  return domainMap;
}

/** Write cookies back to Netscape format */
async function writeNetscapeCookieFile(domain, cookies, outDir) {
  const outPath = path.join(outDir, `${domain}.txt`);
  const header = `# Netscape HTTP Cookie File\n# Generated by session_checker.js\n\n`;
  await fs.promises.mkdir(outDir, { recursive: true });
  await fs.promises.writeFile(outPath, header + cookies.join("\n") + "\n", "utf8");
  return outPath;
}

/** Remove duplicates from domain => {file, mtime, cookies} by picking newest */
function deduplicateDomains(domainFiles) {
  // domainFiles: Map domain => array of {file, mtime, cookies}
  const deduped = new Map();
  for (const [domain, files] of domainFiles.entries()) {
    files.sort((a, b) => b.mtime - a.mtime);
    deduped.set(domain, files[0]);
  }
  return deduped;
}

/** Guess test URL for a domain */
function getTestURL(domain) {
  if (DOMAIN_TEST_URLS[domain]) return DOMAIN_TEST_URLS[domain];
  // Basic guess: https://domain/ or https://www.domain/
  return `https://${domain}/`;
}

/** Checks page content for login keywords */
async function isProbablyLoggedOut(page) {
  const html = await page.content();
  const lower = html.toLowerCase();
  return LOGIN_KEYWORDS.some((kw) => lower.includes(kw));
}

/** Load cookies into Puppeteer page */
async function setCookies(page, domain, cookiesLines) {
  const cookies = [];
  for (const line of cookiesLines) {
    const parts = line.split("\t");
    if (parts.length < 7) continue;
    // Netscape cookie fields: domain, flag, path, secure, expiration, name, value
    const [cookieDomain, , pathVal, secureFlag, expiry, name, value] = parts;
    // Puppeteer cookie format:
    cookies.push({
      name,
      value,
      domain: cookieDomain.startsWith(".") ? cookieDomain.slice(1) : cookieDomain,
      path: pathVal,
      expires: parseInt(expiry),
      httpOnly: false,
      secure: secureFlag.toUpperCase() === "TRUE",
      sameSite: "Lax",
    });
  }
  // Set cookies one-by-one
  try {
    await page.setCookie(...cookies);
  } catch (e) {
    console.warn(`Warning: Failed to set cookies for domain ${domain}:`, e.message);
  }
}

// -------------------------- Main --------------------------

async function main() {
  console.clear();
  console.log(ASCII_HEADER);

  // Select mode
  let mode;
  while (true) {
    const input = await ask("Select mode:\n1) Manual Inspection (y/n prompt)\n2) Auto Inspect (no prompt)\nChoice (1/2): ");
    if (input.trim() === "1" || input.trim() === "2") {
      mode = input.trim();
      break;
    }
    console.log("Invalid choice. Please enter 1 or 2.");
  }
  const manual = mode === "1";

  // Ask for cookie directory
  let cookieDir;
  while (true) {
    const input = await ask("Enter the full path to the cookie directory: ");
    if (input && (await fs.promises.stat(input).catch(() => false))) {
      cookieDir = input;
      break;
    }
    console.log("Invalid directory. Please try again.");
  }

  console.log("\nScanning for cookie files...");
  const cookieFiles = await findCookieFiles(cookieDir);
  if (cookieFiles.length === 0) {
    console.log("No .txt cookie files found in that directory.");
    process.exit(1);
  }
  console.log(`Found ${cookieFiles.length} cookie file(s).\n`);

  // Parse all cookie files & map domain => [{file, mtime, cookies}]
  const domainFiles = new Map();
  for (const file of cookieFiles) {
    try {
      const domainMap = await parseNetscapeCookies(file);
      const stats = await fs.promises.stat(file);
      for (const [domain, cookies] of domainMap.entries()) {
        if (!domainFiles.has(domain)) domainFiles.set(domain, []);
        domainFiles.get(domain).push({ file, mtime: stats.mtimeMs, cookies });
      }
    } catch (e) {
      console.warn(`Failed to parse ${file}: ${e.message}`);
    }
  }

  // Deduplicate domains (pick newest cookie file)
  const dedupedDomains = deduplicateDomains(domainFiles);

  // Prepare output folders
  const outputDir = path.join(cookieDir, "valid_cookies");
  await fs.promises.mkdir(outputDir, { recursive: true });

  // Prepare log file
  const logPath = path.join(cookieDir, "log_session.txt");
  const logStream = fs.createWriteStream(logPath, { flags: "a" });

  // Launch Puppeteer browser once
  const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: null,
  });

  // To avoid duplicates (in case domains appear multiple times)
  const testedDomains = new Set();

  for (const [domain, data] of dedupedDomains.entries()) {
    if (testedDomains.has(domain)) continue;
    testedDomains.add(domain);

    console.log(`\n=== Testing domain: ${domain} ===`);
    const page = await browser.newPage();

    const testUrl = getTestURL(domain);
    // Navigate to the test URL to set context for cookies
    try {
      await page.goto(testUrl, { waitUntil: "networkidle2", timeout: 30000 });
    } catch {
      console.log(`Warning: Failed to load test URL ${testUrl}, trying root domain...`);
      try {
        await page.goto(`https://${domain}/`, { waitUntil: "networkidle2", timeout: 15000 });
      } catch {
        console.log(`Failed to load ${domain} site. Skipping.`);
        await page.close();
        continue;
      }
    }

    // Set cookies
    await setCookies(page, domain, data.cookies);

    // Reload page with cookies
    try {
      await page.reload({ waitUntil: "networkidle2", timeout: 30000 });
    } catch {
      console.log(`Warning: Reload failed for ${domain}. Proceeding.`);
    }

    let loggedIn = false;
    if (manual) {
      console.log(`\nPlease inspect the page for domain: ${domain}`);
      let answer;
      while (true) {
        answer = (await ask("Is this valid with logged in session? (y/n): ")).toLowerCase();
        if (answer === "y" || answer === "n") break;
        console.log("Please enter 'y' or 'n'.");
      }
      loggedIn = answer === "y";
    } else {
      // Auto inspect heuristics
      loggedIn = !(await isProbablyLoggedOut(page));
      console.log(`Auto inspect result for ${domain}: ${loggedIn ? "Logged in" : "Not logged in"}`);
    }

    if (loggedIn) {
      // Save to log
      const logLine = `${new Date().toISOString()} | ${domain} | ${data.file}\n`;
      logStream.write(logLine);
      console.log(`Logged in session saved for ${domain}.`);

      // Save cookies back to valid_cookies folder
      const savedPath = await writeNetscapeCookieFile(domain, data.cookies, outputDir);
      console.log(`Saved cookies to ${savedPath}`);
    } else {
      console.log(`Session invalid or logged out for ${domain}.`);
    }

    await page.close();
  }

  await browser.close();
  logStream.end();
  console.log(`\nAll done! Valid sessions logged to ${logPath}`);
  rl.close();
}

main().catch((e) => {
  console.error("Fatal error:", e);
  rl.close();
  process.exit(1);
});
